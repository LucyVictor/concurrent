
1.非线程安全-多个线程对同一个对象实例变量进行并发访问时产生，体现方式就是"脏读",即读取到的数据是已经其他线程改过的。
线程安全-对于需要获取的实例变量的值而进过同步处理，从而避免"脏读"发生
 
 **无论何时，只有有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。java中的同步机制：synchronized关键字(独占锁)、volatile变量、显示锁、原子变量**

2.可重入锁(锁重入) - 自己可以再次获取自己的内部锁。例如A线程获得了某个对象的锁，此时这个对象锁还没有释放，当再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁

3.线程安全性定义：核心概念在'正确性'，正确性意味着一个类与它的规约保持一致。良好的规约定义了用于强制对象状态的不变约束以及描述操作影响的后验条件。

4.为了避免竞争条件，必须阻止其他线程访问我们正在修改的变量，让我们可以确保：当其他线程想要查看或者修改一个状态时，必须在我们的线程开始之前或完成之后，而不能在操作其中。

5.synchronized(内置锁)包含两个部分的内容：锁对象的引用，以及这个锁保护的代码块。每个java对象都可以隐式的扮演一个用于同步的锁的角色，这些内置的锁被称作内部锁(intrinsic locks)或监视器锁(monitor locks)。执行线程进入synchronized块之前会自动获得锁，无论通过正常控制路径退出，还是从块中异常抛出，线程都会放弃对synchornized块的控制时自动释放锁。获得内部锁的唯一途径：进入这个内部锁保护的代码块或方法。
+ synchronized 是一种互斥锁。意味着至多只有一个线程可拥有锁，当线程A尝试请求线程B所占用的锁时，A必须等待或者阻塞，直到线程B释放了锁。如果B永远不释放锁，A将永远等下去。
+ 对于synchronized方法存在的问题：性能问题

6.锁重入：当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞。对于内部锁是可以重入，因此线程在试图获得它自己占有的锁时，请求会成功。实现原理：通过为每个锁关联一个请求数和一个占有它的线程。当计数为0时，认为锁是未被占有的。线程请求一个未被占有的锁的时，JVM将记录锁的占有者，并将请求数设置为1，如果同意线程再次请求这个锁，计数递增；每次占用线程退出同步快，计数器值将递减，直到计数器达到0时，锁被释放

7.锁保护的变量，意味着每次访问变量的时候都需要获得该锁，确保在同一时刻只有一个线程可以访问到这个变量。若类的不变约束涉及多个变量，那么另外还需要一个附加需求：每个参与到不变约束的变量由同一个锁保护。即：对于每一个涉及多个变量的不变约束，需要同一个锁保护其所有的变量

共享对象
1.内存可见性。我们不仅希望能够避免一个线程修改其他线程正在使用的对象的状态，而且希望确保当一个线程修改了对象的状态之后，其他线程能够看到改变。可以使用显式同步或者内置与类库中的同步机制保证上述要求。

2.synchronized(锁) 与 可见性。由于synchronized是独占锁,对于线程A执行了同步块，线程B随后进入了被同一个锁监视的同步代码块中。那么对于A在同步代码块之中和之前所做的每件事，对于B都是可见的。 当访问一个共享变量时，为什么要求所有的线程由同一个锁进行同步？为了保证一个线程对共享变量进行了修改，其他线程也都可见。
    **锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有的线程都能够看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步**

3.volatile变量
+ 是一种同步弱形式
+ 目的：确保对一个变量的更新以可见的方式告诉告知其他的线程
+ 当一个域声明为volatile类型后，编译器与运行时会监视这个变量,它是共享的，而且对它的操作不会与其他的操作一起被重排序。volatile变量不会缓存在寄存器或者缓存在其他处理器隐藏的地方
+ 综合以上关于volatile的特点，当读取一个volatile类型的变量时，总会返回由某一线程写入的最新值
+ 局限：加锁可以保证可见性与原子性；volatile变量只能保证可见性，例如volatile不足以使自增操作原化
+ 使用volatitle变量的场景,满足以下所有的前置条件：
 - 写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改当前变量的值
 - 变量不需要与其他的状态变量共同参与不变约束
 - 访问变量时，没有其他的原因需要加锁
 
4. 发布与逸出
发布：发布一个对象的意思是使它能够在当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有方法中返回这个引用
逸出：一个对象在尚未准备好时就将它发布，这种情况叫逸出

5. 线程封闭：访问共享、可变的数据要求使用同步。一个可以避免同步的方式就是不共享数据，如果数据仅仅在单线程中被访问，那么就不需要同步。**线程封闭**技术是实现线程安全的最简单的方式之一，当对象封闭在一个线程中，这种做法会自动成为线程安全的。
